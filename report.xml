<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="5" time="9.985" timestamp="2021-04-19T15:35:41.375119" hostname="Work-MBP"><testcase classname="ipynb.BikeCode.ipynb" name="" time="2.214"><failure message="---------------------------------------------------------------------------&#10;from IPython.core.display import HTML&#10;from typing import Iterator, Tuple, List, Dict&#10;import matplotlib&#10;import matplotlib.pyplot as plt&#10;import numpy  as np&#10;import pandas as pd&#10;import re&#10;#x1B[0;31m---------------------------------------------------------------------------#x1B[0m&#10;#x1B[0;31mModuleNotFoundError#x1B[0m                       Traceback (most recent call last)&#10;#x1B[0;32m&lt;ipython-input-1-435db22b2e3b&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m&#10;#x1B[1;32m      4#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mmatplotlib#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mpyplot#x1B[0m #x1B[0;32mas#x1B[0m #x1B[0mplt#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m      5#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mnumpy#x1B[0m  #x1B[0;32mas#x1B[0m #x1B[0mnp#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0;32m----&gt; 6#x1B[0;31m #x1B[0;32mimport#x1B[0m #x1B[0mpandas#x1B[0m #x1B[0;32mas#x1B[0m #x1B[0mpd#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m#x1B[1;32m      7#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mre#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;31mModuleNotFoundError#x1B[0m: No module named 'pandas'">---------------------------------------------------------------------------
from IPython.core.display import HTML
from typing import Iterator, Tuple, List, Dict
import matplotlib
import matplotlib.pyplot as plt
import numpy  as np
import pandas as pd
import re
#x1B[0;31m---------------------------------------------------------------------------#x1B[0m
#x1B[0;31mModuleNotFoundError#x1B[0m                       Traceback (most recent call last)
#x1B[0;32m&lt;ipython-input-1-435db22b2e3b&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m
#x1B[1;32m      4#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mmatplotlib#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mpyplot#x1B[0m #x1B[0;32mas#x1B[0m #x1B[0mplt#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m      5#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mnumpy#x1B[0m  #x1B[0;32mas#x1B[0m #x1B[0mnp#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0;32m----&gt; 6#x1B[0;31m #x1B[0;32mimport#x1B[0m #x1B[0mpandas#x1B[0m #x1B[0;32mas#x1B[0m #x1B[0mpd#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m#x1B[1;32m      7#x1B[0m #x1B[0;32mimport#x1B[0m #x1B[0mre#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;31mModuleNotFoundError#x1B[0m: No module named 'pandas'</failure></testcase><testcase classname="ipynb.Advent of Code.ipynb" name="" time="2.395"><failure message="---------------------------------------------------------------------------&#10;Point = complex             &#10;N, S, E, W = 1j, -1j, 1, -1 # Unit vectors for headings&#10;&#10;def distance(point): &#10;    &quot;City block distance between point and the origin.&quot;&#10;    return abs(point.real) + abs(point.imag)&#10;&#10;def how_far(moves):&#10;    &quot;After following moves, how far away from the origin do we end up?&quot;&#10;    loc, heading = 0, N # Begin at origin, heading North&#10;    for (turn, dist) in parse(moves):&#10;        heading *= turn&#10;        loc += heading * dist&#10;    return distance(loc)&#10;&#10;def parse(text):&#10;    &quot;Return a list of (turn, distance) pairs from text of form 'R2, L42, ...'&quot;&#10;    turns = dict(L=N, R=S)&#10;    return [(turns[RL], int(d))&#10;           for (RL, d) in re.findall(r'(R|L)(\d+)', text)]&#10;&#10;assert distance(Point(3, 4)) == 7 # City block distance; Euclidean distance would be 5&#10;assert parse('R2, L42') == [(S, 2), (N, 42)]&#10;assert how_far(&quot;R2, L3&quot;) == 5&#10;assert how_far(&quot;R2, R2, R2&quot;) == 2&#10;assert how_far(&quot;R5, L5, R5, R3&quot;) == 12&#10;&#10;how_far(Input(1).read())&#10;#x1B[0;31m---------------------------------------------------------------------------#x1B[0m&#10;#x1B[0;31mTypeError#x1B[0m                                 Traceback (most recent call last)&#10;#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m&#10;#x1B[1;32m     26#x1B[0m #x1B[0;32massert#x1B[0m #x1B[0mhow_far#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m&quot;R5, L5, R5, R3&quot;#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m==#x1B[0m #x1B[0;36m12#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     27#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0;32m---&gt; 28#x1B[0;31m #x1B[0mhow_far#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mInput#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m1#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mread#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m&#10;#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36mhow_far#x1B[0;34m(moves)#x1B[0m&#10;#x1B[1;32m      9#x1B[0m     #x1B[0;34m&quot;After following moves, how far away from the origin do we end up?&quot;#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     10#x1B[0m     #x1B[0mloc#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mheading#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0;36m0#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mN#x1B[0m #x1B[0;31m# Begin at origin, heading North#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0;32m---&gt; 11#x1B[0;31m     #x1B[0;32mfor#x1B[0m #x1B[0;34m(#x1B[0m#x1B[0mturn#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mdist#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;32min#x1B[0m #x1B[0mparse#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mmoves#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m#x1B[1;32m     12#x1B[0m         #x1B[0mheading#x1B[0m #x1B[0;34m*=#x1B[0m #x1B[0mturn#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     13#x1B[0m         #x1B[0mloc#x1B[0m #x1B[0;34m+=#x1B[0m #x1B[0mheading#x1B[0m #x1B[0;34m*#x1B[0m #x1B[0mdist#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36mparse#x1B[0;34m(text)#x1B[0m&#10;#x1B[1;32m     18#x1B[0m     #x1B[0mturns#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mdict#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mL#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mN#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mR#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mS#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     19#x1B[0m     return [(turns[RL], int(d))&#10;#x1B[0;32m---&gt; 20#x1B[0;31m            for (RL, d) in re.findall(r'(R|L)(\d+)', text)]&#10;#x1B[0m#x1B[1;32m     21#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     22#x1B[0m #x1B[0;32massert#x1B[0m #x1B[0mdistance#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mPoint#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m3#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0;36m4#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m==#x1B[0m #x1B[0;36m7#x1B[0m #x1B[0;31m# City block distance; Euclidean distance would be 5#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;32m~/.pyenv/versions/3.8.2/lib/python3.8/re.py#x1B[0m in #x1B[0;36mfindall#x1B[0;34m(pattern, string, flags)#x1B[0m&#10;#x1B[1;32m    237#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m    238#x1B[0m     Empty matches are included in the result.&quot;&quot;&quot;&#10;#x1B[0;32m--&gt; 239#x1B[0;31m     #x1B[0;32mreturn#x1B[0m #x1B[0m_compile#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mpattern#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mflags#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mfindall#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mstring#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m#x1B[1;32m    240#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m    241#x1B[0m #x1B[0;32mdef#x1B[0m #x1B[0mfinditer#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mpattern#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mstring#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mflags#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0;36m0#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;31mTypeError#x1B[0m: cannot use a string pattern on a bytes-like object">---------------------------------------------------------------------------
Point = complex             
N, S, E, W = 1j, -1j, 1, -1 # Unit vectors for headings

def distance(point): 
    "City block distance between point and the origin."
    return abs(point.real) + abs(point.imag)

def how_far(moves):
    "After following moves, how far away from the origin do we end up?"
    loc, heading = 0, N # Begin at origin, heading North
    for (turn, dist) in parse(moves):
        heading *= turn
        loc += heading * dist
    return distance(loc)

def parse(text):
    "Return a list of (turn, distance) pairs from text of form 'R2, L42, ...'"
    turns = dict(L=N, R=S)
    return [(turns[RL], int(d))
           for (RL, d) in re.findall(r'(R|L)(\d+)', text)]

assert distance(Point(3, 4)) == 7 # City block distance; Euclidean distance would be 5
assert parse('R2, L42') == [(S, 2), (N, 42)]
assert how_far("R2, L3") == 5
assert how_far("R2, R2, R2") == 2
assert how_far("R5, L5, R5, R3") == 12

how_far(Input(1).read())
#x1B[0;31m---------------------------------------------------------------------------#x1B[0m
#x1B[0;31mTypeError#x1B[0m                                 Traceback (most recent call last)
#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m
#x1B[1;32m     26#x1B[0m #x1B[0;32massert#x1B[0m #x1B[0mhow_far#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m"R5, L5, R5, R3"#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m==#x1B[0m #x1B[0;36m12#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     27#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m
#x1B[0;32m---&gt; 28#x1B[0;31m #x1B[0mhow_far#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mInput#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m1#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mread#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m
#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36mhow_far#x1B[0;34m(moves)#x1B[0m
#x1B[1;32m      9#x1B[0m     #x1B[0;34m"After following moves, how far away from the origin do we end up?"#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     10#x1B[0m     #x1B[0mloc#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mheading#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0;36m0#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mN#x1B[0m #x1B[0;31m# Begin at origin, heading North#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0;32m---&gt; 11#x1B[0;31m     #x1B[0;32mfor#x1B[0m #x1B[0;34m(#x1B[0m#x1B[0mturn#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mdist#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;32min#x1B[0m #x1B[0mparse#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mmoves#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m#x1B[1;32m     12#x1B[0m         #x1B[0mheading#x1B[0m #x1B[0;34m*=#x1B[0m #x1B[0mturn#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     13#x1B[0m         #x1B[0mloc#x1B[0m #x1B[0;34m+=#x1B[0m #x1B[0mheading#x1B[0m #x1B[0;34m*#x1B[0m #x1B[0mdist#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;32m&lt;ipython-input-3-79e323428e2f&gt;#x1B[0m in #x1B[0;36mparse#x1B[0;34m(text)#x1B[0m
#x1B[1;32m     18#x1B[0m     #x1B[0mturns#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mdict#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mL#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mN#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mR#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mS#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     19#x1B[0m     return [(turns[RL], int(d))
#x1B[0;32m---&gt; 20#x1B[0;31m            for (RL, d) in re.findall(r'(R|L)(\d+)', text)]
#x1B[0m#x1B[1;32m     21#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     22#x1B[0m #x1B[0;32massert#x1B[0m #x1B[0mdistance#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mPoint#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m3#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0;36m4#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m==#x1B[0m #x1B[0;36m7#x1B[0m #x1B[0;31m# City block distance; Euclidean distance would be 5#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;32m~/.pyenv/versions/3.8.2/lib/python3.8/re.py#x1B[0m in #x1B[0;36mfindall#x1B[0;34m(pattern, string, flags)#x1B[0m
#x1B[1;32m    237#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m    238#x1B[0m     Empty matches are included in the result."""
#x1B[0;32m--&gt; 239#x1B[0;31m     #x1B[0;32mreturn#x1B[0m #x1B[0m_compile#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mpattern#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mflags#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mfindall#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mstring#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m#x1B[1;32m    240#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m    241#x1B[0m #x1B[0;32mdef#x1B[0m #x1B[0mfinditer#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mpattern#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mstring#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mflags#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0;36m0#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;31mTypeError#x1B[0m: cannot use a string pattern on a bytes-like object</failure></testcase><testcase time="0.000" /><testcase time="0.000" /><testcase time="0.001" /><testcase time="0.001" /><testcase classname="ipynb.Advent-2020.ipynb" name="" time="1.682"><failure message="---------------------------------------------------------------------------&#10;in1: Set[int] = set(data(1, int))&#10;#x1B[0;31m---------------------------------------------------------------------------#x1B[0m&#10;#x1B[0;31mFileNotFoundError#x1B[0m                         Traceback (most recent call last)&#10;#x1B[0;32m&lt;ipython-input-4-f1ec783705fc&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m&#10;#x1B[0;32m----&gt; 1#x1B[0;31m #x1B[0min1#x1B[0m#x1B[0;34m:#x1B[0m #x1B[0mSet#x1B[0m#x1B[0;34m[#x1B[0m#x1B[0mint#x1B[0m#x1B[0;34m]#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mset#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mdata#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m1#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mint#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m&#10;#x1B[0;32m&lt;ipython-input-2-5d65e361ebd2&gt;#x1B[0m in #x1B[0;36mdata#x1B[0;34m(day, parser, sep)#x1B[0m&#10;#x1B[1;32m      1#x1B[0m #x1B[0;32mdef#x1B[0m #x1B[0mdata#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mday#x1B[0m#x1B[0;34m:#x1B[0m #x1B[0mint#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mparser#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mstr#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0msep#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0;34m'\n'#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m-&gt;#x1B[0m #x1B[0mlist#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m      2#x1B[0m     #x1B[0;34m&quot;Split the day's input file into sections separated by `sep`, and apply `parser` to each.&quot;#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0;32m----&gt; 3#x1B[0;31m     #x1B[0msections#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mopen#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34mf'data/advent2020/input{day}.txt'#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mread#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mrstrip#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0msplit#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0msep#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m#x1B[1;32m      4#x1B[0m     #x1B[0;32mreturn#x1B[0m #x1B[0;34m[#x1B[0m#x1B[0mparser#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0msection#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;32mfor#x1B[0m #x1B[0msection#x1B[0m #x1B[0;32min#x1B[0m #x1B[0msections#x1B[0m#x1B[0;34m]#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m      5#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;31mFileNotFoundError#x1B[0m: [Errno 2] No such file or directory: 'data/advent2020/input1.txt'">---------------------------------------------------------------------------
in1: Set[int] = set(data(1, int))
#x1B[0;31m---------------------------------------------------------------------------#x1B[0m
#x1B[0;31mFileNotFoundError#x1B[0m                         Traceback (most recent call last)
#x1B[0;32m&lt;ipython-input-4-f1ec783705fc&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m
#x1B[0;32m----&gt; 1#x1B[0;31m #x1B[0min1#x1B[0m#x1B[0;34m:#x1B[0m #x1B[0mSet#x1B[0m#x1B[0;34m[#x1B[0m#x1B[0mint#x1B[0m#x1B[0;34m]#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mset#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mdata#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;36m1#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mint#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m
#x1B[0;32m&lt;ipython-input-2-5d65e361ebd2&gt;#x1B[0m in #x1B[0;36mdata#x1B[0;34m(day, parser, sep)#x1B[0m
#x1B[1;32m      1#x1B[0m #x1B[0;32mdef#x1B[0m #x1B[0mdata#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0mday#x1B[0m#x1B[0;34m:#x1B[0m #x1B[0mint#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mparser#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0mstr#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0msep#x1B[0m#x1B[0;34m=#x1B[0m#x1B[0;34m'\n'#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;34m-&gt;#x1B[0m #x1B[0mlist#x1B[0m#x1B[0;34m:#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m      2#x1B[0m     #x1B[0;34m"Split the day's input file into sections separated by `sep`, and apply `parser` to each."#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0;32m----&gt; 3#x1B[0;31m     #x1B[0msections#x1B[0m #x1B[0;34m=#x1B[0m #x1B[0mopen#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34mf'data/advent2020/input{day}.txt'#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mread#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0mrstrip#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m.#x1B[0m#x1B[0msplit#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0msep#x1B[0m#x1B[0;34m)#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m#x1B[1;32m      4#x1B[0m     #x1B[0;32mreturn#x1B[0m #x1B[0;34m[#x1B[0m#x1B[0mparser#x1B[0m#x1B[0;34m(#x1B[0m#x1B[0msection#x1B[0m#x1B[0;34m)#x1B[0m #x1B[0;32mfor#x1B[0m #x1B[0msection#x1B[0m #x1B[0;32min#x1B[0m #x1B[0msections#x1B[0m#x1B[0;34m]#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m      5#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;31mFileNotFoundError#x1B[0m: [Errno 2] No such file or directory: 'data/advent2020/input1.txt'</failure></testcase><testcase classname="ipynb.Advent 2017.ipynb" name="" time="2.545"><failure message="---------------------------------------------------------------------------&#10;# Python 3.x Utility Functions&#10;&#10;%matplotlib inline&#10;import matplotlib.pyplot as plt&#10;&#10;import os&#10;import urllib.request&#10;&#10;import re&#10;import numpy as np&#10;import math&#10;import random&#10;import time&#10;&#10;from collections import Counter, defaultdict, namedtuple, deque, abc, OrderedDict&#10;from functools   import lru_cache&#10;from statistics  import mean, median, mode, stdev, variance&#10;from itertools   import (permutations, combinations, chain, cycle, product, islice, &#10;                         takewhile, zip_longest, count as count_from)&#10;from heapq       import heappop, heappush&#10;from numba       import jit&#10;&#10;letters  = 'abcdefghijklmnopqrstuvwxyz'&#10;&#10;cache = lru_cache(None)&#10;&#10;cat = ''.join&#10;&#10;Ø   = frozenset() # Empty set&#10;inf = float('inf')&#10;BIG = 10 ** 999&#10;&#10;################ Functions for Input, Parsing&#10;&#10;def Input(day, year=2017):&#10;    &quot;Open this day's input file.&quot;&#10;    directory = 'advent{}/'.format(year)&#10;    filename = directory+'input{}.txt'.format(day)&#10;    try:&#10;        return open(filename)&#10;    except FileNotFoundError:&#10;        if not os.path.exists(directory):&#10;            os.makedirs(directory)&#10;&#10;        urllib.request.urlretrieve(&quot;https://raw.githubusercontent.com/norvig/pytudes/master/data/&quot; + filename, filename)&#10;        return Input(day)&#10;&#10;def Inputstr(day, year=2017): &#10;    &quot;The contents of this day's input file as a str.&quot;&#10;    return Input(day, year).read().rstrip('\n')&#10;    &#10;def Array(lines):&#10;    &quot;Parse an iterable of str lines into a 2-D array. If `lines` is a str, splitlines.&quot;&#10;    if isinstance(lines, str): lines = lines.splitlines()&#10;    return mapt(Vector, lines)&#10;&#10;def Vector(line):&#10;    &quot;Parse a str into a tuple of atoms (numbers or str tokens).&quot;&#10;    return mapt(Atom, line.replace(',', ' ').split())&#10;&#10;def Integers(text): &#10;    &quot;Return a tuple of all integers in a string.&quot;&#10;    return mapt(int, re.findall(r'-?\b\d+\b', text))&#10;&#10;def Atom(token):&#10;    &quot;Parse a str token into a number, or leave it as a str.&quot;&#10;    try:&#10;        return int(token)&#10;    except ValueError:&#10;        try:&#10;            return float(token)&#10;        except ValueError:&#10;            return token&#10;        &#10;def error(err=RuntimeError, *args): raise err(*args)&#10;&#10;################ Functions on Iterables&#10;&#10;def first(iterable, default=None): &#10;    &quot;The first item in an iterable, or default if it is empty.&quot;&#10;    return next(iter(iterable), default)&#10;&#10;def first_true(iterable, pred=None, default=None):&#10;    &quot;&quot;&quot;Returns the first true value in the iterable.&#10;    If no true value is found, returns *default*&#10;    If *pred* is not None, returns the first item&#10;    for which pred(item) is true.&quot;&quot;&quot;&#10;    # first_true([a,b,c], default=x) --&gt; a or b or c or x&#10;    # first_true([a,b], fn, x) --&gt; a if fn(a) else b if fn(b) else x&#10;    return next(filter(pred, iterable), default)&#10;&#10;def nth(iterable, n, default=None):&#10;    &quot;Returns the nth item of iterable, or a default value&quot;&#10;    return next(islice(iterable, n, None), default)&#10;&#10;def upto(iterable, maxval):&#10;    &quot;From a monotonically increasing iterable, generate all the values &lt;= maxval.&quot;&#10;    # Why &lt;= maxval rather than &lt; maxval? In part because that's how Ruby's upto does it.&#10;    return takewhile(lambda x: x &lt;= maxval, iterable)&#10;&#10;identity = lambda x: x&#10;&#10;def groupby(iterable, key=identity):&#10;    &quot;Return a dict of {key(item): [items...]} grouping all items in iterable by keys.&quot;&#10;    groups = defaultdict(list)&#10;    for item in iterable:&#10;        groups[key(item)].append(item)&#10;    return groups&#10;&#10;def grouper(iterable, n, fillvalue=None):&#10;    &quot;&quot;&quot;Collect data into fixed-length chunks:&#10;    grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx&quot;&quot;&quot;&#10;    args = [iter(iterable)] * n&#10;    return zip_longest(*args, fillvalue=fillvalue)&#10;&#10;def overlapping(iterable, n):&#10;    &quot;&quot;&quot;Generate all (overlapping) n-element subsequences of iterable.&#10;    overlapping('ABCDEFG', 3) --&gt; ABC BCD CDE DEF EFG&quot;&quot;&quot;&#10;    if isinstance(iterable, abc.Sequence):&#10;        yield from (iterable[i:i+n] for i in range(len(iterable) + 1 - n))&#10;    else:&#10;        result = deque(maxlen=n)&#10;        for x in iterable:&#10;            result.append(x)&#10;            if len(result) == n:&#10;                yield tuple(result)&#10;                &#10;def pairwise(iterable):&#10;    &quot;s -&gt; (s0,s1), (s1,s2), (s2, s3), ...&quot;&#10;    return overlapping(iterable, 2)&#10;&#10;def sequence(iterable, type=tuple):&#10;    &quot;Coerce iterable to sequence: leave alone if already a sequence, else make it `type`.&quot;&#10;    return iterable if isinstance(iterable, abc.Sequence) else type(iterable)&#10;&#10;def join(iterable, sep=''):&#10;    &quot;Join the items in iterable, converting each to a string first.&quot;&#10;    return sep.join(map(str, iterable))&#10;                &#10;def powerset(iterable):&#10;    &quot;Yield all subsets of items.&quot;&#10;    items = list(iterable)&#10;    for r in range(len(items)+1):&#10;        for c in combinations(items, r):&#10;            yield c&#10;            &#10;def quantify(iterable, pred=bool):&#10;    &quot;Count how many times the predicate is true.&quot;&#10;    return sum(map(pred, iterable))&#10;&#10;def length(iterable):&#10;    &quot;Same as len(list(iterable)), but without consuming memory.&quot;&#10;    return sum(1 for _ in iterable)&#10;&#10;def shuffled(iterable):&#10;    &quot;Create a new list out of iterable, and shuffle it.&quot;&#10;    new = list(iterable)&#10;    random.shuffle(new)&#10;    return new&#10;    &#10;flatten = chain.from_iterable&#10;&#10;################ Functional programming&#10;&#10;def mapt(fn, *args): &#10;    &quot;Do a map, and make the results into a tuple.&quot;&#10;    return tuple(map(fn, *args))&#10;&#10;def map2d(fn, grid):&#10;    &quot;Apply fn to every element in a 2-dimensional grid.&quot;&#10;    return tuple(mapt(fn, row) for row in grid)&#10;&#10;def repeat(n, fn, arg, *args, **kwds):&#10;    &quot;Repeat arg = fn(arg) n times, return arg.&quot;&#10;    return nth(repeatedly(fn, arg, *args, **kwds), n)&#10;&#10;def repeatedly(fn, arg, *args, **kwds):&#10;    &quot;Yield arg, fn(arg), fn(fn(arg)), ...&quot;&#10;    yield arg&#10;    while True:&#10;        arg = fn(arg, *args, **kwds)&#10;        yield arg&#10;        &#10;def compose(f, g): &#10;    &quot;The function that computes f(g(x)).&quot;&#10;    return lambda x: f(g(x))&#10;&#10;################ Making immutable objects&#10;            &#10;class Set(frozenset):&#10;    &quot;A frozenset, but with a prettier printer.&quot;&#10;    def __repr__(self): return '{' + join(sorted(self), ', ') + '}'&#10;    &#10;def canon(items, typ=None):&#10;    &quot;Canonicalize these order-independent items into a hashable canonical form.&quot;&#10;    typ = typ or (cat if isinstance(items, str) else tuple)&#10;    return typ(sorted(items))&#10;            &#10;################ Math Functions&#10;            &#10;def transpose(matrix): return tuple(zip(*matrix))&#10;&#10;def isqrt(n):&#10;    &quot;Integer square root (rounds down).&quot;&#10;    return int(n ** 0.5)&#10;&#10;def ints(start, end, step=1):&#10;    &quot;The integers from start to end, inclusive: range(start, end+1)&quot;&#10;    return range(start, end + 1, step)&#10;&#10;def floats(start, end, step=1.0):&#10;    &quot;Yield floats from start to end (inclusive), by increments of step.&quot;&#10;    m = (1.0 if step &gt;= 0 else -1.0)&#10;    while start * m &lt;= end * m:&#10;        yield start&#10;        start += step&#10;        &#10;def multiply(numbers):&#10;    &quot;Multiply all the numbers together.&quot;&#10;    result = 1&#10;    for n in numbers:&#10;        result *= n&#10;    return result&#10;&#10;import operator as op&#10;&#10;operations = {'&gt;': op.gt, '&gt;=': op.ge, '==': op.eq,&#10;              '&lt;': op.lt, '&lt;=': op.le, '!=': op.ne,&#10;              '+': op.add, '-': op.sub, '*': op.mul, &#10;              '/': op.truediv, '**': op.pow}&#10;&#10;################ 2-D points implemented using (x, y) tuples&#10;&#10;def X(point): return point[0]&#10;def Y(point): return point[1]&#10;&#10;origin = (0, 0)&#10;HEADINGS = UP, LEFT, DOWN, RIGHT = (0, -1), (-1, 0), (0, 1), (1, 0)&#10;&#10;def turn_right(heading): return HEADINGS[HEADINGS.index(heading) - 1]&#10;def turn_around(heading):return HEADINGS[HEADINGS.index(heading) - 2]&#10;def turn_left(heading):  return HEADINGS[HEADINGS.index(heading) - 3]&#10;&#10;def add(A, B): &#10;    &quot;Element-wise addition of two n-dimensional vectors.&quot;&#10;    return mapt(sum, zip(A, B))&#10;&#10;def neighbors4(point): &#10;    &quot;The four neighboring squares.&quot;&#10;    x, y = point&#10;    return (          (x, y-1),&#10;            (x-1, y),           (x+1, y), &#10;                      (x, y+1))&#10;&#10;def neighbors8(point): &#10;    &quot;The eight neighboring squares.&quot;&#10;    x, y = point &#10;    return ((x-1, y-1), (x, y-1), (x+1, y-1),&#10;            (x-1, y),             (x+1, y),&#10;            (x-1, y+1), (x, y+1), (x+1, y+1))&#10;&#10;def cityblock_distance(P, Q=origin): &#10;    &quot;Manhatten distance between two points.&quot;&#10;    return sum(abs(p - q) for p, q in zip(P, Q))&#10;&#10;def distance(P, Q=origin): &#10;    &quot;Straight-line (hypotenuse) distance between two points.&quot;&#10;    return sum((p - q) ** 2 for p, q in zip(P, Q)) ** 0.5&#10;&#10;def king_distance(P, Q=origin):&#10;    &quot;Number of chess King moves between two points.&quot;&#10;    return max(abs(p - q) for p, q in zip(P, Q))&#10;&#10;################ Debugging &#10;&#10;def trace1(f):&#10;    &quot;Print a trace of the input and output of a function on one line.&quot;&#10;    def traced_f(*args):&#10;        result = f(*args)&#10;        print('{}({}) = {}'.format(f.__name__, ', '.join(map(str, args)), result))&#10;        return result&#10;    return traced_f&#10;&#10;def grep(pattern, iterable):&#10;    &quot;Print lines from iterable that match pattern.&quot;&#10;    for line in iterable:&#10;        if re.search(pattern, line):&#10;            print(line)&#10;            &#10;class Struct:&#10;    &quot;A structure that can have any fields defined.&quot;&#10;    def __init__(self, **entries): self.__dict__.update(entries)&#10;    def __repr__(self): &#10;        fields = ['{}={}'.format(f, self.__dict__[f]) &#10;                  for f in sorted(self.__dict__)]&#10;        return 'Struct({})'.format(', '.join(fields))&#10;&#10;################ A* and Breadth-First Search (tracking states, not actions)&#10;&#10;def always(value): return (lambda *args: value)&#10;&#10;def Astar(start, moves_func, h_func, cost_func=always(1)):&#10;    &quot;Find a shortest sequence of states from start to a goal state (where h_func(s) == 0).&quot;&#10;    frontier  = [(h_func(start), start)] # A priority queue, ordered by path length, f = g + h&#10;    previous  = {start: None}  # start state has no previous state; other states will&#10;    path_cost = {start: 0}     # The cost of the best path to a state.&#10;    Path      = lambda s: ([] if (s is None) else Path(previous[s]) + [s])&#10;    while frontier:&#10;        (f, s) = heappop(frontier)&#10;        if h_func(s) == 0:&#10;            return Path(s)&#10;        for s2 in moves_func(s):&#10;            g = path_cost[s] + cost_func(s, s2)&#10;            if s2 not in path_cost or g &lt; path_cost[s2]:&#10;                heappush(frontier, (g + h_func(s2), s2))&#10;                path_cost[s2] = g&#10;                previous[s2] = s&#10;&#10;def bfs(start, moves_func, goals):&#10;    &quot;Breadth-first search&quot;&#10;    goal_func = (goals if callable(goals) else lambda s: s in goals)&#10;    return Astar(start, moves_func, lambda s: (0 if goal_func(s) else 1))&#10;#x1B[0;31m---------------------------------------------------------------------------#x1B[0m&#10;#x1B[0;31mModuleNotFoundError#x1B[0m                       Traceback (most recent call last)&#10;#x1B[0;32m&lt;ipython-input-1-98c110e04f09&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m&#10;#x1B[1;32m     19#x1B[0m                          takewhile, zip_longest, count as count_from)&#10;#x1B[1;32m     20#x1B[0m #x1B[0;32mfrom#x1B[0m #x1B[0mheapq#x1B[0m       #x1B[0;32mimport#x1B[0m #x1B[0mheappop#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mheappush#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0;32m---&gt; 21#x1B[0;31m #x1B[0;32mfrom#x1B[0m #x1B[0mnumba#x1B[0m       #x1B[0;32mimport#x1B[0m #x1B[0mjit#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[0m#x1B[1;32m     22#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m&#10;#x1B[1;32m     23#x1B[0m #x1B[0mletters#x1B[0m  #x1B[0;34m=#x1B[0m #x1B[0;34m'abcdefghijklmnopqrstuvwxyz'#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m&#10;&#10;#x1B[0;31mModuleNotFoundError#x1B[0m: No module named 'numba'">---------------------------------------------------------------------------
# Python 3.x Utility Functions

%matplotlib inline
import matplotlib.pyplot as plt

import os
import urllib.request

import re
import numpy as np
import math
import random
import time

from collections import Counter, defaultdict, namedtuple, deque, abc, OrderedDict
from functools   import lru_cache
from statistics  import mean, median, mode, stdev, variance
from itertools   import (permutations, combinations, chain, cycle, product, islice, 
                         takewhile, zip_longest, count as count_from)
from heapq       import heappop, heappush
from numba       import jit

letters  = 'abcdefghijklmnopqrstuvwxyz'

cache = lru_cache(None)

cat = ''.join

Ø   = frozenset() # Empty set
inf = float('inf')
BIG = 10 ** 999

################ Functions for Input, Parsing

def Input(day, year=2017):
    "Open this day's input file."
    directory = 'advent{}/'.format(year)
    filename = directory+'input{}.txt'.format(day)
    try:
        return open(filename)
    except FileNotFoundError:
        if not os.path.exists(directory):
            os.makedirs(directory)

        urllib.request.urlretrieve("https://raw.githubusercontent.com/norvig/pytudes/master/data/" + filename, filename)
        return Input(day)

def Inputstr(day, year=2017): 
    "The contents of this day's input file as a str."
    return Input(day, year).read().rstrip('\n')
    
def Array(lines):
    "Parse an iterable of str lines into a 2-D array. If `lines` is a str, splitlines."
    if isinstance(lines, str): lines = lines.splitlines()
    return mapt(Vector, lines)

def Vector(line):
    "Parse a str into a tuple of atoms (numbers or str tokens)."
    return mapt(Atom, line.replace(',', ' ').split())

def Integers(text): 
    "Return a tuple of all integers in a string."
    return mapt(int, re.findall(r'-?\b\d+\b', text))

def Atom(token):
    "Parse a str token into a number, or leave it as a str."
    try:
        return int(token)
    except ValueError:
        try:
            return float(token)
        except ValueError:
            return token
        
def error(err=RuntimeError, *args): raise err(*args)

################ Functions on Iterables

def first(iterable, default=None): 
    "The first item in an iterable, or default if it is empty."
    return next(iter(iterable), default)

def first_true(iterable, pred=None, default=None):
    """Returns the first true value in the iterable.
    If no true value is found, returns *default*
    If *pred* is not None, returns the first item
    for which pred(item) is true."""
    # first_true([a,b,c], default=x) --&gt; a or b or c or x
    # first_true([a,b], fn, x) --&gt; a if fn(a) else b if fn(b) else x
    return next(filter(pred, iterable), default)

def nth(iterable, n, default=None):
    "Returns the nth item of iterable, or a default value"
    return next(islice(iterable, n, None), default)

def upto(iterable, maxval):
    "From a monotonically increasing iterable, generate all the values &lt;= maxval."
    # Why &lt;= maxval rather than &lt; maxval? In part because that's how Ruby's upto does it.
    return takewhile(lambda x: x &lt;= maxval, iterable)

identity = lambda x: x

def groupby(iterable, key=identity):
    "Return a dict of {key(item): [items...]} grouping all items in iterable by keys."
    groups = defaultdict(list)
    for item in iterable:
        groups[key(item)].append(item)
    return groups

def grouper(iterable, n, fillvalue=None):
    """Collect data into fixed-length chunks:
    grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"""
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)

def overlapping(iterable, n):
    """Generate all (overlapping) n-element subsequences of iterable.
    overlapping('ABCDEFG', 3) --&gt; ABC BCD CDE DEF EFG"""
    if isinstance(iterable, abc.Sequence):
        yield from (iterable[i:i+n] for i in range(len(iterable) + 1 - n))
    else:
        result = deque(maxlen=n)
        for x in iterable:
            result.append(x)
            if len(result) == n:
                yield tuple(result)
                
def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    return overlapping(iterable, 2)

def sequence(iterable, type=tuple):
    "Coerce iterable to sequence: leave alone if already a sequence, else make it `type`."
    return iterable if isinstance(iterable, abc.Sequence) else type(iterable)

def join(iterable, sep=''):
    "Join the items in iterable, converting each to a string first."
    return sep.join(map(str, iterable))
                
def powerset(iterable):
    "Yield all subsets of items."
    items = list(iterable)
    for r in range(len(items)+1):
        for c in combinations(items, r):
            yield c
            
def quantify(iterable, pred=bool):
    "Count how many times the predicate is true."
    return sum(map(pred, iterable))

def length(iterable):
    "Same as len(list(iterable)), but without consuming memory."
    return sum(1 for _ in iterable)

def shuffled(iterable):
    "Create a new list out of iterable, and shuffle it."
    new = list(iterable)
    random.shuffle(new)
    return new
    
flatten = chain.from_iterable

################ Functional programming

def mapt(fn, *args): 
    "Do a map, and make the results into a tuple."
    return tuple(map(fn, *args))

def map2d(fn, grid):
    "Apply fn to every element in a 2-dimensional grid."
    return tuple(mapt(fn, row) for row in grid)

def repeat(n, fn, arg, *args, **kwds):
    "Repeat arg = fn(arg) n times, return arg."
    return nth(repeatedly(fn, arg, *args, **kwds), n)

def repeatedly(fn, arg, *args, **kwds):
    "Yield arg, fn(arg), fn(fn(arg)), ..."
    yield arg
    while True:
        arg = fn(arg, *args, **kwds)
        yield arg
        
def compose(f, g): 
    "The function that computes f(g(x))."
    return lambda x: f(g(x))

################ Making immutable objects
            
class Set(frozenset):
    "A frozenset, but with a prettier printer."
    def __repr__(self): return '{' + join(sorted(self), ', ') + '}'
    
def canon(items, typ=None):
    "Canonicalize these order-independent items into a hashable canonical form."
    typ = typ or (cat if isinstance(items, str) else tuple)
    return typ(sorted(items))
            
################ Math Functions
            
def transpose(matrix): return tuple(zip(*matrix))

def isqrt(n):
    "Integer square root (rounds down)."
    return int(n ** 0.5)

def ints(start, end, step=1):
    "The integers from start to end, inclusive: range(start, end+1)"
    return range(start, end + 1, step)

def floats(start, end, step=1.0):
    "Yield floats from start to end (inclusive), by increments of step."
    m = (1.0 if step &gt;= 0 else -1.0)
    while start * m &lt;= end * m:
        yield start
        start += step
        
def multiply(numbers):
    "Multiply all the numbers together."
    result = 1
    for n in numbers:
        result *= n
    return result

import operator as op

operations = {'&gt;': op.gt, '&gt;=': op.ge, '==': op.eq,
              '&lt;': op.lt, '&lt;=': op.le, '!=': op.ne,
              '+': op.add, '-': op.sub, '*': op.mul, 
              '/': op.truediv, '**': op.pow}

################ 2-D points implemented using (x, y) tuples

def X(point): return point[0]
def Y(point): return point[1]

origin = (0, 0)
HEADINGS = UP, LEFT, DOWN, RIGHT = (0, -1), (-1, 0), (0, 1), (1, 0)

def turn_right(heading): return HEADINGS[HEADINGS.index(heading) - 1]
def turn_around(heading):return HEADINGS[HEADINGS.index(heading) - 2]
def turn_left(heading):  return HEADINGS[HEADINGS.index(heading) - 3]

def add(A, B): 
    "Element-wise addition of two n-dimensional vectors."
    return mapt(sum, zip(A, B))

def neighbors4(point): 
    "The four neighboring squares."
    x, y = point
    return (          (x, y-1),
            (x-1, y),           (x+1, y), 
                      (x, y+1))

def neighbors8(point): 
    "The eight neighboring squares."
    x, y = point 
    return ((x-1, y-1), (x, y-1), (x+1, y-1),
            (x-1, y),             (x+1, y),
            (x-1, y+1), (x, y+1), (x+1, y+1))

def cityblock_distance(P, Q=origin): 
    "Manhatten distance between two points."
    return sum(abs(p - q) for p, q in zip(P, Q))

def distance(P, Q=origin): 
    "Straight-line (hypotenuse) distance between two points."
    return sum((p - q) ** 2 for p, q in zip(P, Q)) ** 0.5

def king_distance(P, Q=origin):
    "Number of chess King moves between two points."
    return max(abs(p - q) for p, q in zip(P, Q))

################ Debugging 

def trace1(f):
    "Print a trace of the input and output of a function on one line."
    def traced_f(*args):
        result = f(*args)
        print('{}({}) = {}'.format(f.__name__, ', '.join(map(str, args)), result))
        return result
    return traced_f

def grep(pattern, iterable):
    "Print lines from iterable that match pattern."
    for line in iterable:
        if re.search(pattern, line):
            print(line)
            
class Struct:
    "A structure that can have any fields defined."
    def __init__(self, **entries): self.__dict__.update(entries)
    def __repr__(self): 
        fields = ['{}={}'.format(f, self.__dict__[f]) 
                  for f in sorted(self.__dict__)]
        return 'Struct({})'.format(', '.join(fields))

################ A* and Breadth-First Search (tracking states, not actions)

def always(value): return (lambda *args: value)

def Astar(start, moves_func, h_func, cost_func=always(1)):
    "Find a shortest sequence of states from start to a goal state (where h_func(s) == 0)."
    frontier  = [(h_func(start), start)] # A priority queue, ordered by path length, f = g + h
    previous  = {start: None}  # start state has no previous state; other states will
    path_cost = {start: 0}     # The cost of the best path to a state.
    Path      = lambda s: ([] if (s is None) else Path(previous[s]) + [s])
    while frontier:
        (f, s) = heappop(frontier)
        if h_func(s) == 0:
            return Path(s)
        for s2 in moves_func(s):
            g = path_cost[s] + cost_func(s, s2)
            if s2 not in path_cost or g &lt; path_cost[s2]:
                heappush(frontier, (g + h_func(s2), s2))
                path_cost[s2] = g
                previous[s2] = s

def bfs(start, moves_func, goals):
    "Breadth-first search"
    goal_func = (goals if callable(goals) else lambda s: s in goals)
    return Astar(start, moves_func, lambda s: (0 if goal_func(s) else 1))
#x1B[0;31m---------------------------------------------------------------------------#x1B[0m
#x1B[0;31mModuleNotFoundError#x1B[0m                       Traceback (most recent call last)
#x1B[0;32m&lt;ipython-input-1-98c110e04f09&gt;#x1B[0m in #x1B[0;36m&lt;module&gt;#x1B[0;34m#x1B[0m
#x1B[1;32m     19#x1B[0m                          takewhile, zip_longest, count as count_from)
#x1B[1;32m     20#x1B[0m #x1B[0;32mfrom#x1B[0m #x1B[0mheapq#x1B[0m       #x1B[0;32mimport#x1B[0m #x1B[0mheappop#x1B[0m#x1B[0;34m,#x1B[0m #x1B[0mheappush#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0;32m---&gt; 21#x1B[0;31m #x1B[0;32mfrom#x1B[0m #x1B[0mnumba#x1B[0m       #x1B[0;32mimport#x1B[0m #x1B[0mjit#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m
#x1B[0m#x1B[1;32m     22#x1B[0m #x1B[0;34m#x1B[0m#x1B[0m
#x1B[1;32m     23#x1B[0m #x1B[0mletters#x1B[0m  #x1B[0;34m=#x1B[0m #x1B[0;34m'abcdefghijklmnopqrstuvwxyz'#x1B[0m#x1B[0;34m#x1B[0m#x1B[0;34m#x1B[0m#x1B[0m

#x1B[0;31mModuleNotFoundError#x1B[0m: No module named 'numba'</failure></testcase><testcase classname="ipynb.Cheryl.ipynb" name="" time="1.296" /><testcase time="0.000" /><testcase time="0.000" /><testcase time="0.000" /><testcase time="0.000" /></testsuite></testsuites>